---
title: 计算机进制转换
date: "2023-06-13 09:37:48"
tags: 计算机
categories: 
  - Reverse
description: "了解如何在计算机中不同数制之间的转换。"
toc: true
indexing: false
---

# 进制

进制也就是进位计数制，是人为定义的带进位的计数方法（有不带进位的计数方法，比如原始的结绳计数法，唱票时常用的“正”字计数法，以及类似的tally mark计数）。 对于任何一种进制---X进制，就表示每一位上的数运算时都是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。

在我们的日常生产生活当中一般采用的都是10进制，但是普通计算机内部一般采用的是2进制，在表示一组2进制时（例如内存值）又习惯于使用16进制进行描述。

# 整数进制转换

## 二进制转其他进制

### 二进制转八进制

二进制转八进制一般可以采用**421法**。将二进制每三位分割后，按位乘421对应的值，然后将每个部分值进行累加。

例如：11010101011

| 位     | 1    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 1    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 对应值 | 2    | 1    | 4    | 2    | 1    | 4    | 2    | 1    | 4    | 2    | 1    |

十六进制位：3253

![image-20230612135322884](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306121353909.png)

### 二进制转十进制

二进制转十进制一般采用**位权累加法**。将二进制的每一位的值乘以对应位权值，然后把结果累加起来。

如：110110

| 值         | 1    | 1    | 0    | 1    | 1    | 0    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 权值       | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |
| 计算结果值 | 32   | 16   | 0    | 4    | 2    | 0    |

将所有的值加起来结果为：54

![二进制转十进制](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306121333437.png)

### 二进制转十六进制

二进制转十六进制一般采用**8421法**。将二进制每四位分割后，按位乘8421对应的值，然后将每个部分值进行累加。

例如：11010101011

| 位     | 1    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 1    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 对应值 | 4    | 2    | 1    | 8    | 4    | 2    | 1    | 8    | 4    | 2    | 1    |

十六进制位：6AB

![image-20230612134030082](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306121340102.png)



## 其他进制转二进制

### 八进制转二进制

八进制转二进制一般可以采用**逆421法**。

例如八进制数13253转成二进制。

| 位值       | 1    | 3    | 2    | 5    | 3    |
| ---------- | ---- | ---- | ---- | ---- | ---- |
| 二进制排列 | 001  | 011  | 010  | 101  | 011  |

所以二进制为：001011010101011，分割后为：001 0110 1010 1011

![image-20230612135851368](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306121358391.png)

### 十进制转二进制

十进制转二进制一般可以采用**除2取余法**。将十进制数除以2，得到对应的余数。**先得到余数在低位，**按照这样的顺序即可得到二进制数。

例如：十进制数5803

| 当前值 | 除以2余数 |
| ------ | --------- |
| 5803   | 1         |
| 2901   | 1         |
| 1450   | 0         |
| 725    | 1         |
| 362    | 0         |
| 181    | 1         |
| 90     | 0         |
| 45     | 1         |
| 22     | 0         |
| 11     | 1         |
| 5      | 1         |
| 2      | 0         |
| 1      | 1         |

所以二进制数为：1011010101011，分割后为：1 0110 1010 1011

![image-20230612140739807](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306121407834.png)

### 十六进制转二进制

十六进制转二进制采用**逆8421法**。如将十六进制0x16AB转成二进制。

| 位值       | 1    | 6    | A    | B    |
| ---------- | ---- | ---- | ---- | ---- |
| 二进制排列 | 0001 | 0110 | 1010 | 1011 |

所以二进制为：0001011010101100，分割后为：0001 0110 1010 1011



## 其他进制转其他进制

其他进制转其他进制的时候一般可以先转二进制，再用二进制转成目标进制。比如说将八进制转成十六进制，可以先将八进制转成二进制再准成十六进制。



# 小数

## 十进制小数转二进制

**整数部分按照整数转成二进制，小数部分乘2取整，直到余数为0。**

例如：4.375

整数部分二进制：0100

小数部分：

| 乘2计算          | 整数 | 余数 |
| ---------------- | ---- | ---- |
| 0.375 * 2 = 0.75 | 0    | 0.75 |
| 0.75 * 2 = 1.5   | 1    | 0.5  |
| 0.5 * 2 = 1      | 1    | 0    |

所以二进制为：0100.011

但是很多十进制小数不能转成二进制，比如说0.2：

```
00110011001100110011001100110011001100110011001101
```

这里会出现`0011`循环的情况。**所以小数的判断方法，不能直接相等，因为可能会无法达到这个小数，可以相减，要求大于负精度，小于精度。**

## 定点小数方案

规定整数部分占用多少个字节，小数部分占用多少个字节。比如整数和小数部分各使用一半。

c1 c2 | c3 c4

c1 c2存放整数，c3 c4存放小数。

优点：效率高。

缺点：表示的数值小，浪费存储空间。

### 浮点小数方案

以4字节为例，第一位表示符号，后8位表示指数，剩下的23位表示数值

S EEEEEEEE DDDDDDDDDDDDDDDDDDDDDDD

例如：14.375		

转成二进制：1110.011

转成指数表示：1.110011 * 2^3，保存数据时，小数点前的1为固定值（1），所以在保存时可以省略。

指数需要记录正负数，这里采取取中间值（127）作为0点，小于127表明是负数，大于127为正数。所以这里需要127

内存表示为：0 10000010 110011DDDDDDDDDD0000000

转成十六进制为：0100 0001 0110 011D DDDD DDDD D000 0000   ====> 41 66 00 00，内存中表示为 00 00 66 41

![image-20230612231134536](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306122311570.png)

**练习：**

- 地址0013ff74的内容为：00 68 45 44，系统为小尾，如果存放的是float，其十进制数为多少？

  ```
  1. 值
  	44 45 68 00
  2. 转成二进制
  	0100 0100 0100 0101 0110 1000 0000 0000
  3. 分割
  	0 10001000 10001010110100000000000
  4. 计算
  10001000 = 136，所以是大于0的值。
  136-127=9
  1.100010101101 * 2^9 = 1100010101.101
  
  整数：1100010 = 789
  小数：0.101 = 0.625
  
  所以10进制数为789.625
  ```

- 将895.75转换成float类型的16进制数。其中895的二进制为：1101111111

  ```
  1. 将整数和小数转成二进制
  	895 = 1101111111
  	0.75 = 0.11
  2. 求指数值
  	1101111111.11 = 1.10111111111 * 2^9
    指数值为：127+9= 136
    二进制为：10001000
  
  2. 符号位。正数，符号位为0
  3. 表示
  	0 10001000 10111111111000000000000
  4. 转成16进制
  	0100 0100 0101 1111 1111 0000 0000 0000
  	44 5f f0 00
  	所以16进制数为0x445ff000
  	
  5. 内存中小尾排列为：
  	00 f0 5f 44
  
  ```

- 调试结果

  ![image-20230612234634342](https://pics-place.oss-cn-shanghai.aliyuncs.com/pic/202306122346381.png)



# 计算机加减乘除实现方法

## 加法

计算机直接做加法运算。

## 乘法

利用左移和加法实现。

例如：Reg * 0b10011

```
Reg * 0b10011
= Reg * (10000 + 10 + 1)
= Reg*10000 + Reg*10 + Reg*1
= Reg<<4 + Reg<<1 + Reg
```

## 除法

转化成乘法和移位来进行计算。

``` 
R1/R2
=R1 * 2^n/R2 * 1/(2^n)				n>32
计算机预存所有根号(2^n)所有质数的值。
```

## 减法

利用补码相加溢出进位来计算。

```
假设R1、R2都为1字节
R1 - R2
= R1 + 0x100-R2 -0x100

又因为 R + ~R = 0xff
所以 R + ~R +1 = 0x100
即 0x100 - R = ~R + 1

= R1 + ~R2 + 1 - 0x100
= R1 + neg(R2) 丢掉进位
```

> neg为求补码运算。

**补码：**

补码是一种编码，求补码是一种运算。求补码的方式为 **取反加1**。

补码编码方式：

- 最高有效位：0表示正，1表示负。
- 当为正数时，直接存储数据；当数据为负数时，其余各位为求补后的值。

补码练习：

| 值   | 中间二进制 | 补码                         | 真值 |
| ---- | ---------- | ---------------------------- | ---- |
| 88   | 0101 1000  | 0101 1000                    | 0x58 |
| -88  | 1010 0111  | 1010 1000                    | 0xA8 |
| 0x88 | 1000 1000  | 1111 1000                    | -120 |
| 0x80 | 1000 0000  | 1111 1111 + 1 => 1 0000 0000 | -128 |

> 0x80可以理解为 -0，也可以理解为 -128。但是 +0 和 -0 都是表示0，这里一般用作表示 -128.
